source: industry is duckdb.table('data/SICcodes.csv') extend {
    --dimension: sic is SIC:::number
   -- rename: SECOffice is column1
    rename: Industry_Name is column2
    rename: SIC is column0--:::number
    except: column1
    dimension: Industry_Name_nc is replace(Industry_Name,',','.')
        
    primary_key: SIC
}

source: sub is duckdb.table('data/sub-01-2026.parquet') extend {

    join_one: industry with sic
    measure: 
    num_companies is count(cik)
    num_submissions is count(adsh)
    num_industries is count(industry.Industry_Name)
    num_10Ks is count(cik) {where: form = "10-K"}
    num_10Ks_amended is count(cik) {where: form = "10-K/A"}
    # percent
    pct_amended is count(cik) {where: form = "10-K/A"} / count(cik) {where: form = "10-K"}
    

    dimension: 
    --SIC_f3 is substr(zip_code::string,1,3)
    --accepted_hour is hour(accepted)

    --filed_str is filed::string
    name_no_comma is replace(company_name,',','.')
    --cik_str is cik::string
    --division is trunc(sic / 1000)
    --industry_code is trunc(sic / 10)
    --dimension: major_code is trunc(sic / 100)
      --dimension: city_and_state_country is concat(city, ', ', state, ', ', country)
 -- dimension: city_and_state is concat(city, ', ', state,)    
 -- dimension: cik_str is cik::string
  --dimension: sic_str is sic::string
  --dimension: name_no_comma is replace(company_name,',','.')
  --measure: no_reports is count(cik)
  primary_key: adsh
  measure: --major_code is trunc(sic / 100)
   --period_timestamp is period::timestamp
   num_days_period_to_filed is avg(days(period to filed))
  --  num_days_filed_to_acc is avg(days(filed to accepted::date))
   -- num_minutes_filed_to_acc is avg(minutes(filed::timestamp to accepted))
   -- dimension: industry_code is trunc(sic / 10)
  --  dimension: division is trunc(sic / 1000)
    dimension: filer_type is pick "Large Accelerated Filer" when afs = "1-LAF" 
                                    pick "Accelerated Filer" when afs = "2-ACC"
                                    pick "Smaller Reporting Accelerated" when afs = "3-SRA"
                                    pick "Non-Accelerated Filer" when afs = "4-NON"
                                    pick "Smaller Reporting Filer" when afs = "5-SML"
                                    else null
    
    except: detail, ein, floataxis, floatdate, floatmems, instance, nciks, prevrpt, pubfloatusd
    bas1, bas2, baph, former, mas1, mas2, zipma, stprma, wksi, cityma, countryma, changed, aciks
    rename:
    state is stprba
    country is countryba
    city is cityba
    zip_code is zipba
    fiscal_period is fp
    fiscal_year is fy
    fiscal_year_end is fye
    state_of_incorporation is stprinc
    company_name is name
    country_of_incorporation is countryinc

# bar_chart
view: by_year_10K_sub is{
    group_by: Fiscal_Period_Close is period.year
    aggregate: num_submissions
    where: form = "10-K" --and period.year > @2011
}  

view: by_industry is{
    group_by: sic, industry.Industry_Name
    aggregate: num_companies
    --where: form = "10-K" and period = @2023
}

view: by_name is{
        group_by: company_name
        limit: 20
}

view: by_fiscal_year_end is {
    group_by: fiscal_year_end
    aggregate: num_companies
    limit: 10
}

view: by_state is{
        group_by: state
        aggregate: num_submissions
        limit: 20
}

view: by_city is{
        group_by: city
        aggregate: num_submissions
        limit: 20
}

view: by_zip_code is{
        group_by: zip_code
        aggregate: num_submissions
        limit: 20
}

view: by_country is{
        group_by: country
        aggregate: num_submissions
        limit: 20
}

view: by_form_type is{
        group_by: form
        aggregate: num_submissions
        limit: 20
}
 
view: by_fiscal_period is{
    group_by: Fiscal_Period_Close is period.year
    aggregate: num_submissions
    limit: 20
    --where: form = "10-K" --and period.year > @2011
} 


# bar_chart {size=spark y.independent}
view: by_fiscal_period_bar_spark is{
    group_by: Fiscal_Period_Close is period.year
    aggregate: num_submissions
    limit: 20
    --where: form = "10-K" --and period.year > @2011
} 

view: by_filer_type is {
    group_by: filer_type, afs
    aggregate: num_submissions
}
# bar_chart
view: by_filed_date is {
    group_by: filed.year
    aggregate: num_submissions
}
}


// industries by year
 -- # bar_chart - nested
 --1.	Basic Information: Number of companies, number of industries, 
--## renderer_legacy
run: sub -> {
    group_by: industry.Industry_Name
    aggregate: num_companies is count(adsh)
    unique_co is count(cik)
    where: form = "10-K" and period.year > @2014 --and sic = null
    # bar_chart
    nest: by_sic is {
         group_by: period.year
         aggregate: num_companies
    --    limit: 70
     }
}
//table shows percentage growth
run: sub -> {
    group_by: industry.Industry_Name
    --group_by: period.year
    aggregate: num_companies_2022 is count(cik) {where: period.year = @2022 }
    aggregate: num_companies_2015 is count(cik) {where: period.year = @2015 }
    # percent
    aggregate: pct_increase_15_22 is (count(cik) {where: period.year = @2022 } - count(cik) {where: period.year = @2015 } )/ count(cik) {where: period.year = @2015 }
    --unique_co is count(cik)
    where: form = "10-K" --and period.year = @2022 --and sic = null
    order_by: num_companies_2022 desc
}

run: sub -> {
    group_by: filed
    aggregate: count1 is count(cik)
    where: form = "10-K" and filed.year = @2023
    order_by: count1 desc
}
--Q1-1
--Number of companies (submitting 10-Ks per year)
--## renderer_legacy



--Q1-2
##
# bar_chart
run: sub -> {
    group_by: Fiscal_Period_Close is period.year
    aggregate: Unique_Industries is count(industry.Industry_Name)
    where: form = "10-K" and period.year >= @2011
}

--Q1-3
run: sub -> {
    group_by: form
    aggregate: Number_of_forms_submitted is count(adsh)
}

--Q2
// unique cik all years
run: sub -> {
    group_by: industry.Industry_Name
    aggregate: unique_co is count(cik)
    where: form = "10-K" --and period.year > @2010 and period.year <@2024 --and sic = null
}
-- unique cik all years - through time
--Q2-1 -- unique co with sparkline
run: sub -> {
    group_by: Industry_Name is industry.Industry_Name
    aggregate: unique_co is count(cik)
    where: form = "10-K" and period.year >= @2011 and period.year < @2024
    # line_chart { size=spark }
    nest: trend_2011_to_2023 is {
         group_by: period.year
         aggregate: num_companies is count(adsh)
     }
}

//looking at 10-K/As
// by industry, by year
run: sub -> {
    group_by: form
    aggregate: unique_co is count(cik)
    where: form = "10-K/A"
   -- # bar_chart

    --# bar_chart
        nest: by_ind is {
            group_by: industry.Industry_Name
            aggregate: unique_co is count(cik)
        # bar_chart        
        nest: by_year is {
         group_by: period.year
         aggregate: num_companies is count(adsh)
  
    }
        }
    --    } limit: 70}
}
//Q3-1
// Amended Returns by Year
# bar_chart
run: sub -> {
    group_by: Period_Close is period.year
    aggregate: amended_10Ks is count(cik)
    where: form = "10-K/A" and period.year >= @2011 and period.year < @2024
}
//looking at 10-K/As 
//by year, by ind
//
run: sub -> {
    group_by: form
    aggregate: unique_co is count(adsh)
    where: form = "10-K/A"
    # bar_chart
    nest: by_year is {
         group_by: period.year
         aggregate: num_companies is count(adsh)
    }
    --# bar_chart
        nest: by_ind is {
            group_by: industry.Industry_Name
            aggregate: unique_co is count(cik)
        }
    --    } limit: 70}
}
// count of amended returns by year
run: sub -> {
    --group_by: 
    group_by: period.year
    aggregate: num_companies is count(), unique_companies is count(cik)--, comp2plus is count({where: cik > 2 }
    where: form = "10-K/A"
    --    } limit: 70}
}

run: sub -> {
    --group_by: 
    group_by: period.year
    aggregate: num_companies is count(adsh), unique_companies is count(cik), comp2plus is count(cik) {where: form = "10-K/A" }
    where: form = "10-K/A"
    --    } limit: 70}
}

-- number of amended retursn
run: sub -> {
    group_by: industry.Industry_Name, period.year
    aggregate: unique_co is count(cik) {where: form = "10-K"}
    orgs_with_amended_10k is count(cik) {where: form = "10-K/A"}
    --co_10K is count(cik) {where: form = "10-K"}
    # percent
    perct_a is count(cik) {where: form = "10-K/A"} / count(cik) {where: form = "10-K"}
    order_by: perct_a desc 
    --where: unique_co > 10
    --    } limit: 70}
} 

// industries with 10-K / As
run: sub -> {
    group_by: industry.Industry_Name--, period.year
    aggregate: unique_co is count(cik) {where: form = "10-K"}
    orgs_with_amended_10k is count(cik) {where: form = "10-K/A"}
    --co_10K is count(cik) {where: form = "10-K"}
    # percent
    perct_a is count(cik) {where: form = "10-K/A"} / count(cik) {where: form = "10-K"}
    order_by: orgs_with_amended_10k desc 
    --    } limit: 70}
} 
//nest industries with most 10/K A by year
run: sub -> {
    group_by: period.year
    where: form = "10-K" or form = "10-K/A"
    nest: by_sic is {
    group_by: industry.Industry_Name
    aggregate: unique_co is count(cik) {where: form = "10-K"}
    co_w_a is count(cik) {where: form = "10-K/A"}
    --co_10K is count(cik) {where: form = "10-K"}
    # percent
    perct_a is count(cik) {where: form = "10-K/A"} / count(cik) {where: form = "10-K"}
    having: unique_co > 20
    order_by: perct_a desc 
    limit:10
    --    } limit: 70}
    }
} 

--Q3 -- good
run: sub -> {
    group_by: industry.Industry_Name

    aggregate: unique_co is count(cik)
    aggregate: total_filed_10ks is count(adsh) {where: form = "10-K"}
    --# percent
    --aggregate: pct_total is count(adsh) / all(count())
     --growth is count(cik) {where: period.year = @2023} - count(cik) {where: period.year = @2011}
   
    # hidden
    diff_abs is abs(count(cik) {where: period.year = @2023} - count(cik) {where: period.year = @2011})
 
    --having: count(cik) {where: form = "10-K/A" and period.year = @2023} > 5
    aggregate: ind_size_2023 is count(cik) {where: period.year = @2023}
    having: ind_size_2023 > 60
    order_by: pct_a_2023 desc
    # number="0.0%"
    aggregate:  pct_a_2023 is count(adsh) {where: form = "10-K/A" and period.year = @2023} / count(adsh) {where: form = "10-K" and period.year = @2023}
     # number="0.0%"
    aggregate:  pct_a_all is count(adsh) {where: form = "10-K/A"} / count(adsh) {where: form = "10-K"}
   
     
     # line_chart { size=spark }

    nest: trend_2023_to_2011 is {
        group_by: year_close is period.year
        aggregate: perct_a is count(cik) {where: form = "10-K/A"} / count(cik) {where: form = "10-K"}
        where: period.year >= @2011 and period.year < @2024
    }
}

run: sub -> {
    group_by: industry.Industry_Name
    where: form = "10-K/A" or form = "10-K"
    nest: by_year is {
    group_by:  period.year
    aggregate: unique_co is count(cik) {where: form = "10-K"}
    co_w_a is count(cik) {where: form = "10-K/A"}
    --co_10K is count(cik) {where: form = "10-K"}
    # percent
    perct_a is count(cik) {where: form = "10-K/A"} / count(cik) {where: form = "10-K"}
    having: unique_co > 20
    order_by: perct_a desc 
    limit:10
    --    } limit: 70}
    }
} 

// industries by year
 -- # bar_chart - nested
 --1.	Basic Information: Number of companies, number of industries, 
--## renderer_legacy
--# line_chart
run: sub -> {
    group_by: 
    year1 is period.year, industry.Industry_Name
    aggregate: 
    num_companies is count(adsh)
    where: form = "10-K" and period.year > @2015
    --order_by: year1 --and sic = null
}

// industries by year -- good one
 -- # bar_chart
run: sub -> {
    group_by: industry.SIC, industry.Industry_Name
    aggregate: num_companies is count(adsh)
    where: form = "10-K" --and period = @2021 --and sic = null
    # bar_chart
    nest: by_sic is {
        group_by: period.year
        aggregate: num_companies is count(adsh)
        --limit: 70
     }
}


// industries by state
 -- # bar_chart
run: sub -> {
    group_by: state
    aggregate: num_companies is count(company_name)
    where: form = "10-K" --and period = @2021 --and sic = null
    # bar_chart
    nest: by_ind is {
        group_by: industry.Industry_Name
        aggregate: num_companies is count(company_name)
        limit: 8
     }
}

// industries by zip code
 -- # bar_chart
run: sub -> {
    group_by: zip_code, state
    aggregate: num_companies is count(company_name)
    where: form = "10-K" --and period = @2021 --and sic = null
    # bar_chart
    nest: by_ind is {
        group_by: industry.Industry_Name
        aggregate: num_companies is count(company_name)
        limit: 8
     }
}

// industries by first 3 zip
 -- # bar_chart
run: sub -> {
    group_by: industry.Industry_Name
    aggregate: num_companies is count(company_name)
    where: form = "10-K" --and SIC_f3 = '958' or SIC_f3 = '956' or SIC_f3 = '957' or SIC_f3 = '942' or SIC_f3 = '945' --and period = @2021 --and sic = null
    --# bar_chart
    -- nest: by_ind is {
    --     group_by: industry.Industry_Name
    --     aggregate: num_companies is count(company_name)
    --     limit: 8
    --  }
}

//change sic code
run: sub -> {
    group_by: company_name, sic, period.year
    --aggregate: num_companies is count(company_name)
    where: form = "10-K" --and SIC_f3 = '958' or SIC_f3 = '956' or SIC_f3 = '957' or SIC_f3 = '942' or SIC_f3 = '945' --and period = @2021 --and sic = null
    --# bar_chart
    -- nest: by_ind is {
    --     group_by: industry.Industry_Name
    --     aggregate: num_companies is count(company_name)
    --     limit: 8
    --  }
}

// change in SIC code??
run: sub -> {
  select: adsh, cik, company_name, sic, period.quarter
  calculate: r is row_number() {partition_by: company_name; order_by: sic}
} -> {
  select: *
  where: r = 1
}

//replicate Josh Alan Lee's code
//change in zip

--   --select: *
  
--   group_by: old_sic
--   aggregate: sic_1 is count()
--   where: change_in_sic = "True"
-- }




--2nd copy


run: sub -> {
    group_by: state
    aggregate: num_cos is count(cik)
    where: form = "10-K" and period.year >= @2011 and period.year < @2024
    # line_chart
    nest: by_year is {
        group_by: period.year 
        aggregate: num_cos is count(cik)
    }
}










run: sub -> {
    group_by: industry.Industry_Name_nc
    aggregate: count_tot is count(cik)
    having: count(cik) < 5
    nest: by_top_country is {
        group_by: country
        limit: 1
        aggregate: count_in_c is count(cik)
    }
}

//away vs to cities
//best one -- table of most - for paper

--## renderer_legacy
-- industries by percent 8-K
-- 8-K analysis
run: sub -> {
        group_by: industry.Industry_Name
        aggregate: num_orgs is count(cik) --{where: form = "10-K"}
        num_8ks is count(adsh) {where: form = "8-K"}
        aggregate: per_co_8k is count(adsh) {where: form = "8-K"} / count(cik) {where: form = "10-K"}
        order_by: per_co_8k desc
        having: num_orgs > 19
        where: form = "10-K" or form = "8-K" and period < @2024 and period.day > @2010
         # line_chart { size=spark }
         --# bar_chart
        nest: by_8k_per_year is {
            group_by: period.year
            --aggregate: count_co is count(cik)
            --aggregate: count_8k is count(adsh) {where: form = "8-K"}
            aggregate: avg_8k_per_year is count(adsh) {where: form = "8-K"} / count(cik) {where: form = "10-K"}
            --where: form = "10-K" or form = "8-K" and period.quarter < @2023-12-01 and period.quarter > @2011-01-01
            --aggregate:   --and country = "US"} / count(adsh) 
            --aggregate: per_co_year_8ka is count(adsh) {where: form and country = "US"} / count(adsh) 
        }

}



--instate vs outstate simple
--summary statistics


--instate vs outstate simple
--summary statistics --for paper





run: sub -> {
    group_by: industry.Industry_Name
    aggregate: totalcos_2011 is count(cik) {where: period.year = @2011}
    aggregate: totalcos_2023 is count(cik) {where: period.year = @2023}
    aggregate: abs_growth is count(cik) {where: period.year = @2023} - count(cik) {where: period.year = @2011}
  # number="0%"
    aggregate: pct_growth is (count(cik) {where: period.year = @2023} - count(cik) {where: period.year = @2011}) / count(cik) {where: period.year = @2011}
 
    order_by: pct_growth desc
    --having: totalcos_2011 > 100
    where: form = "10-K"  and period.year >= @2011 and period.year < @2024
      
      
}


--sparkline
--for paper
run: sub -> {
    group_by: industry.Industry_Name
    aggregate: unique_co is count(cik)
    # hidden
    aggregate: total_filed_10ks is count(adsh)
    --# percent
    --aggregate: pct_total is count(adsh) / all(count())
    aggregate: totalcos_2011 is count(cik) {where: period.year = @2011}
    aggregate: totalcos_2023 is count(cik) {where: period.year = @2023}
    --growth is count(cik) {where: period.year = @2023} - count(cik) {where: period.year = @2011}
    # percent
    pct_growth is ((count(cik) {where: period.year = @2023} - (count(cik) {where: period.year = @2011})) / (count(cik) {where: period.year = @2011}))
    # hidden
    abs_pct_growth is abs((count(cik) {where: period.year = @2023} - (count(cik) {where: period.year = @2011})) / (count(cik) {where: period.year = @2011}))

    # hidden
    diff_abs is abs(count(cik) {where: period.year = @2023} - count(cik) {where: period.year = @2011})
    order_by: abs_pct_growth desc
    having: totalcos_2011 >= 8
    where: form = "10-K"  and period.year >= @2011 and period.year < @2024
    --# line_chart { size=spark }
    --  nest: by_top_3_states is {
    --         group_by: stprma
    --         aggregate: totalco is count(cik)
    --         where: country = "US"
    --         limit: 3
    # line_chart { size=spark }
     nest: by_time is {
                 group_by: period.year
                 aggregate: totalco1 is count(cik)
    }   
}



//replicate Josh Alan Lee's code
//change in zip
run: sub -> {
    group_by: name_no_comma --, filed_str, fy, zip_code, zipma, city, cityma, state, stprma, stprinc, afs, form, sic, period, industry.Industry_Name
    --limit: 1000
    where: form = "10-K" --| "10-Q"
   
   --order_by: name_no_comma, filed_str
   having: count(sic) > 1
   nest: by_stuff is {
    group_by: name_no_comma, period.year, sic, industry.Industry_Name
   }
--calculate: changed is lag(address) { partition_by: company_name; order_by: something }
-- } -> {
--     group_by: by_stuff.name_no_comma --, industry.Industry_Name
}
